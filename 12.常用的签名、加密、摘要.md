## 摘要算法

常用签名特征：

- `MD5`：128位（16字节）的哈希值，通常表示为32个十六进制字符的字符串。例：`65a8e27d8879283831b664bd8b7f0ad4`

- `SHA`：
  `SHA-1` 160位 20字节 40个十六进制字符数  
  `2ef7bde608ce5404e97d5f042f95f89f1c232871`
  `SHA-224` 224位 28字节 56个十六进制字符数  `7509e5bda0c790bd2237f30198406d6dee3fd9dbf8a159742bbf7b35dfa607e6b1`
  `SHA-256` 256位 32字节 64个十六进制字符数  `dff9f635e95f328830bb4c1df673cdd4654f2299dcb9a40fad5f98ccddacbebc`
  `SHA-384` 384位 48字节 96个十六进制字符数  `59e1748777448c69de6b800d7a33bbfb9ff1b463e44354c3553bcdb9c666fa90125a2fecd9e3673435d90f2dfad27bba1`
  `SHA-512` 512位 64字节 128个十六进制字符数  `309ecc489c12d6eb4cc40f50c902f2b4d0ed77ee511a7c7a9bcd3ca86d4cd86f989dd35bc5ff499670da34255b45b0cfd830e81f605dcf7dc5542e93ae9cd76f`

- `HMAC`：密钥的安全性是`HMAC`的核心。`HMAC` 是一种基于哈希函数的消息认证码，通常与`SHA-256`、`SHA-1`等哈希算法结合使用。
  `HMAC-SHA-1`  160位 20字节 40个十六进制字符数
  `HMAC-SHA-256`  256位 32字节 64个十六进制字符数

  `HMAC-SHA-512`  512位 64字节 128个十六进制字符数
  `HMAC-MD5`  128位 16字节 32个十六进制字符数

### 1. MD5

简介：全称` MD5` 消息摘要算法，又称哈希算法、散列算法，由美国密码学家`罗纳德·李维斯特`设计，于 1992 年作为 RFC 1321 被公布，用以取代 `MD4` 算法。摘要算法是单向加密的，也就是说明文通过摘要算法加密之后，是不能解密的。摘要算法的第二个特点密文是固定长度的，它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用`16进制`的字符串表示）。之所以叫摘要算法，它的算法就是提取明文重要的特征。所以，两个不同的明文，使用了摘要算法之后，有可能他们的密文是一样的，不过这个概率非常的低。

#### 1.1 JavaScript 实现

安装对应的模块

```javascript
// 在依赖项中添加包： --save
npm install crypto-js  --save
```

**使用案例**

```JavaScript
// 引用 crypto-js 加密模块
var CryptoJS = require('crypto-js')

function MD5Test() {
    var text = "I love python!"
    return CryptoJS.MD5(text).toString()
}

console.log(MD5Test()) 
```

#### 1.2 Python 实现

```python
import hashlib

def md5_test2():
    md5 = hashlib.md5()
    md5.update('python'.encode('utf-8'))
    print(md5.hexdigest())

if __name__ == '__main__':
    md5_test2() 
```

**总结：**`MD5`哈希视为字符串，而是将其视为十六进制数， `MD5`哈希长度为128位，通常由`32`个十六进制数字表示。



### 2. SHA

简介：全称安全哈希算法，由美国国家安全局`（NSA）`所设计，主要适用于数字签名标准里面定义的数字签名算法，`SHA` 通常指 `SHA` 家族的五个算法，分别是` SHA-1、SHA-224、SHA-256、SHA-384、SHA-512`，`SHA` 是比 `MD5` 更安全一点的摘要算法，`MD5` 的密文是 32 位，而 `SHA-1` 是 40 位，版本越强，密文越长，代价是速度越慢。

#### 2.1  JavaScript 实现

```JavaScript
// 引用 crypto-js 加密模块
var CryptoJS = require('crypto-js')

function SHA1Encrypt() {
    var text = "I love python!"
    return CryptoJS.SHA1(text).toString();
}

console.log(SHA1Encrypt()) 
```

#### 2.2 Python 实现

```python
import hashlib

def sha1_test2():
    sha1 = hashlib.sha1()
    sha1.update('I love python!'.encode('utf-8'))
    print(sha1.hexdigest())

if __name__ == '__main__':
    sha1_test2() 
```

#### 2.3 `sha`系列特征

```
sha1:23c02b203bd2e2ca19da911f1d270a06d86719fb
sha224:1ffeffcbe2707dc5d1c10df619203c1a3b620c70394b3c4c106d92e6
sha256:c3a845a318cd654749ea4db6f4d5f9cb5c6e5b0cade46d9dc04af46d32049c7c
sha512:af47f324b77a4885748bfc3f0d9b5a846c0153c589852bb3f185ab6e7a600547b818ab994776e8d24584457f9aac84246b0de971584cebbdd96aa1aee6630f9f
```

总结：根据长度进行定位、主要还是要去JavaScript里面下断点调试分析



### 3. `HMAC`

简介：全称散列消息认证码、密钥相关的哈希运算消息认证码，于 1996 年提出，1997 年作为 RFC 2104 被公布，`HMAC` 加密算法是一种安全的基于加密 `Hash` 函数和共享密钥的消息认证协议，它要求通信双方共享密钥 key、约定算法、对报文进行 `Hash` 运算，形成固定长度的认证码。通信双方通过认证码的校验来确定报文的合法性。

参考资料：

- 百科：https://baike.baidu.com/item/hmac/7307543?fr=aladdin

#### 3.1 JavaScript 实现

```JavaScript
// 引用 crypto-js 加密模块
var CryptoJS = require('crypto-js')

function HMACEncrypt() {
    var text = "I love python!"
    var key = "secret"   // 密钥文件
    return CryptoJS.HmacMD5(text, key).toString();
    // return CryptoJS.HmacSHA1(text, key).toString();
    // return CryptoJS.HmacSHA256(text, key).toString();
}
console.log(HMACEncrypt())
```

#### 3.2 Python 实现

```python
import hmac

def hmac_test1():
    message = 'I love python!'.encode()
    key = b'secret'
    md5 = hmac.new(key, message, digestmod='MD5')
    print(md5.hexdigest())

def hmac_test2():
    key = 'secret'.encode('utf8')
    sha1 = hmac.new(key, digestmod='sha1')
    sha1.update('I love '.encode('utf8'))
    sha1.update('Python!'.encode('utf8'))
    print(sha1.hexdigest())

if __name__ == '__main__':
    hmac_test1()  # 9c503a1f852edcc3526ea56976c38edf
    hmac_test2()  # 2d8449a4292d4bbeed99ce9ea570880d6e19b61a
```



### 4. 实战案例

#### 1 案例 `md5`加密逆向

#####  **逆向目标**

+ 主页：https://www.mytokencap.com/

+ 逆向字段：`code: '9c503a1f852edcc3526ea56976c38edf'`

##### **逆向分析**

1. 先进行抓包，可以看到有一个签名信息 `code`

   这里推荐下`xhr`断点调试进行分析，这里直接发送请求了而且code已经生成，我们走到该函数入口；
   ![image-20241223150011990](.\image\image-20241223150011990.png)
   ![image-20241223150224542](.\image\image-20241223150224542.png)
   上面看到入口就已经是包含code参数了，继续跟栈；
   跟踪到一个请求拦截器中，如下，你会发现e = o()(r + "9527" + r.substr(0, 6));是我们想要的n.data.code的生成位置。断点并进入函数o()()，o()是返回一个函数所以这里操作的函数为o()()。
   ![image-20241223150626322](.\image\image-20241223150626322.png)
   ![image-20241223151332764](.\image\image-20241223151332764.png)
   这里是就是加密地点了，可以webpack扣代码允许或者控制台输出一下就知道这个加密是啥了。

##### **python代码模拟**

```python
import hashlib,time
// o()(n + "9527" + n.substr(0, 6))

def md5_test2():
    n = str(int(time.time())*1000)
    value = n + "9527" + n[0:6]
    md5 = hashlib.md5()
    md5.update(value.encode('utf-8'))
    print(md5.hexdigest())

if __name__ == '__main__':
    md5_test2() 
```



#### 2 案例`sha256`系列

**逆向目标**

+ 主页：http://www.hh1024.com/

+ 接口：https://ucp.hrdjyun.com:60359/api/dy

+ 逆向参数：`sign: "0d2864b1420c42f12de6efeff30bcb4b458157d8177675b8910fa632524604cb"`

#####  python代码实现

```python
import urllib3,requests,time,json
urllib3.disable_warnings()
import hashlib

months = input("请输入查询月份：")
days = input("请输入查询日期,2天以内：")
times = str(int(time.time()) * 1000)
params = {"no":"dy0002","data":{"days":1,"rankType":5,"liveDay":f"2023-{months.zfill(2)}-{days.zfill(2)}"}}
print(params)
dd = json.dumps(params)
def get_sign():
    data = f'param={dd}&timestamp={times}&tenant=1&salt=kbn%&)@<?FGkfs8sdf4Vg1*+;`kf5ndl$'  # 要进行加密的数据
    data_sha = hashlib.sha256(data.encode('utf-8')).hexdigest()
    return data_sha

def get_data():
    headers = {
        "Content-Type": "application/json;charset=UTF-8",
        "Host": "ucp.hrdjyun.com:60359",
        "Origin": "http://www.hh1024.com",
        "Pragma": "no-cache",
        "sec-ch-ua": "\"Google Chrome\";v=\"107\", \"Chromium\";v=\"107\", \"Not=A?Brand\";v=\"24\"",
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": "\"Windows\"",
        "Sec-Fetch-Dest": "empty",
        "Sec-Fetch-Mode": "cors",
        "Sec-Fetch-Site": "cross-site",
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36"
    }
    session = requests.session()
    s = get_sign()
    t = "这里面是登陆后的token值"
    datas = {"param":dd,"sign":s,"tenant":"1","timestamp":times,"token":t}
    url = 'https://ucp.hrdjyun.com:60359/api/dy'
    res = session.post(url,headers=headers,data=json.dumps(datas))
    if res.json().get('status') == 0:
        data = res.json().get('data')['rankList']
        for d in data:
            items = {}
            items['抖音名'] = d.get('anchorName')
            items['带货销量'] ='%.2f' % (d.get('salesVolume') / 10000) + '万'
            print(items)

if __name__ == '__main__':
    reads = """
        本接口只开放抖音带货销量日榜
        可以根据日期查询
                                --- 夏洛
        """
    print(reads)
    get_data()
```



#### 3 案例`Hmac`系列

##### 1. **逆向目标**

+ 主页：https://www.qcc.com/
+ 接口:https://www.qcc.com/api/datalist/touzilist?keyNo=5dffb644394922f9073544a08f38be9f&pageIndex=2
+ 逆向字段：`code: '9c503a1f852edcc3526ea56976c38edf'`

##### 2. **逆向分析**

- 定位加密的位置
- 关键字定位

```JavaScript
// 前端代码赋值请求头的代码
aa.setRequestHeader('sign', '值')
aa.headers['sign'] = '值'
aa.headers: {}
// 可以搜索这些关键字定位
```

- 调试定位

```
调试定位在异步的js代码里面比较麻烦,我们可以先定位到异步执行代码之前下好断点,先快速的过一般,在脑海里有大楷的印象,看看数据大致的生成位置,前面先粗调试,确定好大致位置之后再精调
```

![image-20241223172200976](.\image\image-20241223172200976.png)

- 可以看出我们的请求头在这里生成的
- i的生成是`(0,a.default)(t, e.data)`
- l的生成是`l = (0,r.default)(t, e.data, (0,s.default)());`
- `(0,r.default)`是js的逗号操作符我们可以直接`r.default()`来进行调用
- 键值对都是通过网址来进行加密的,可以直接进函数进行对比

##### 3. 逆向结果

- JavaScript代码

```JavaScript
var cryptojs = require('crypto-js')

var dd = {
    "n": 20,
    "codes": {
        "0": "W",
        "1": "l",
        "2": "k",
        "3": "B",
        "4": "Q",
        "5": "g",
        "6": "f",
        "7": "i",
        "8": "i",
        "9": "r",
        "10": "v",
        "11": "6",
        "12": "A",
        "13": "K",
        "14": "N",
        "15": "k",
        "16": "4",
        "17": "L",
        "18": "1",
        "19": "8"
    }
}
var r = function () {
    for (var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "/").toLowerCase(), t = e + e, n = "", i = 0; i < t.length; ++i) {
        var a = t[i].charCodeAt() % dd.n;
        n += dd.codes[a]
    }
    return n
};

var r1 = function (e, t) {
    return cryptojs.HmacSHA512(e, t).toString();
};


var s = function () {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
        , t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "/").toLowerCase()
        , n = JSON.stringify(e).toLowerCase();
    return (0,
        r1)(t + n, (0,
        r)(t)).toLowerCase().substr(8, 20)
};


var s1 = function () {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
        , t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ""
        , n = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "/").toLowerCase()
        , i = JSON.stringify(e).toLowerCase();
    return r1(n + "pathString" + i + t,
        r(n))
};

function xxx(t) {
    data = undefined
    var i = (0,
        s)(t, data)

    l = s1(t, data, '210314b3d12062c234e868105494964d')
    return {
        'key': i,
        'value': l
    }

}

t = "/api/datalist/holdcolist?isnewagg=true&keyno=6b242b475738f45a4dd180564d029aa9&pageindex=7"
xxx(t)
```

- python代码

```python
import requests
import execjs


class Qcc():
    def __init__(self):
        self.headers = {
            'cookie': 'qcc_did=4ec3aa37-7e00-4ba3-8981-4561cd125939; UM_distinctid=18a6ad8612d1ad-0dbe600f638f27-26031f51-1fa400-18a6ad8612e17f9; CNZZDATA1254842228=338542179-1694009680-%7C1694700549; QCCSESSID=c79eec2efbd4d79857830f58a7',
            "referer": "https://www.qcc.com/firm/6b242b475738f45a4dd180564d029aa9.html",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
        }
        self.url = "https://www.qcc.com/api/datalist/holdcolist?isNewAgg=true&keyNo=6b242b475738f45a4dd180564d029aa9&pageIndex={}"

    def get_data(self):
        for i in range(1, 3):
            js = execjs.compile(open('demo.js', encoding='utf-8').read())
            pa = '/api/datalist/holdcolist?isnewagg=true&keyno=6b242b475738f45a4dd180564d029aa9&pageindex={}'.format(i)
            he = js.call('xxx', pa)
            self.headers[he['key']] = he['value']
            response = requests.get(self.url.format(i), headers=self.headers)
            print(response.text)


if __name__ == '__main__':
    qcc = Qcc()
    qcc.get_data()

```



## 对称加密

对称加密（加密解密密钥相同）：DES、3DES、AES、RC4

**简介**

对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。

![image-20241223173807875](.\image\image-20241223173807875.png)

### 一. 常见算法归纳

**DES：**56位密钥，由于密钥太短，被逐渐被弃用。

**AES：**有128位、192位、256位密钥，现在比较流行。密钥长、可以增加破解的难度和成本。



#### 1. 工作模式归纳

##### 1. ECB模式 

- 全称Electronic Codebook模式，译为电子密码本模式，每个数据块独立进行加/解密

- ECB是最简单的工作模式，原理就是将明文分组，对每一组分别单独加密，加密后的每组密文之间没有联系,在将每一组加密的结果进行拼接

![image-20241223175546796](.\image\image-20241223175546796.png)

- 解密流程如下

![image-20241223175553035](.\image\image-20241223175553035.png)



##### 2. CBC模式 

- 全称Cipher Block Chaining模式，译为密文分组链接模式

- 这种模式的核心思想是每一个明文分组在被加密之前要与前一个的密文分组进行异或运算，即每一组的加密结果会参与下一个分组的加密，因此第一个分组加密需要有一个初始化向量（IV）参与。
- 最后将每个密文分组按顺序合并起来就得到加密结果
- CBC模式是分组加密中使用最多的模式。

![image-20241223175657314](.\image\image-20241223175657314.png)

- 解密方式

![image-20241223175702672](.\image\image-20241223175702672.png)

##### 3. **CFB模式** 

- 全称Cipher FeedBack模式，译为密文反馈模式
- 这种工作模式吸收了流加密(流加密可以逐个加密数据，因此适用于流式数据，无需等待整个块加密完成)的特点，可以理解成实现了流加密的CBC 模式
- 加密时，首先对初始化向量（IV）加密，用加密的结果与第一个明文分组异或，得到第一个密文分组
- 然后将此密文分组进行加密（加密前要进行移位处理），将加密结果与第二个明文分组异或

![image-20241223175810153](.\image\image-20241223175810153.png)

- 解密过程与加密过程相似，仍然是将前一密文分组加密**（注意，这里仍然是加密，不是解密）**，用加密结果与当前密文分组异或，得到明文

![image-20241223175851299](.\image\image-20241223175851299.png)

##### 4. **OFB模式** 

- 全称Output Feedback模式，译为输出反馈模式。
- OFB模式与CFB模式类似，区别在于使用上一个分组的密码序列加密生成当前分组的密码序列

![image-20241223175930793](.\image\image-20241223175930793.png)

- 解密过程

![image-20241223175956290](.\image\image-20241223175956290.png)

##### 5. **CTR模式** 

- 全称Counter模式，译为计数器模式。
- CTR模式与CFB、OFB模式为同一类。但它是通过将逐次累加的计数器进行加密来生成密码序列
- 也就是说，每一个的密文分组是通过将计数器加密得到的密码序列与明文分组进行异或而得到的

![image-20241223180045480](.\image\image-20241223180045480.png)

- 解密过程   

![image-20241223180113061](.\image\image-20241223180113061.png)

##### 6. 总结

![image-20241223180138387](.\image\image-20241223180138387.png)

- ECB模式和CBC是最常见的加密模式



### 二. DES算法

实例地址：https://bqcm0.cavip1.com/

简介：**DES**是一种分组**加密算法**，他以`64`位为分组对数据加密。`64`位一组的明文从算法的一端 输入，`64`位的密文从另一端输出。**DES**是一个对称算法：加密和解密用的是同一个算法（除 密钥编排不同以外）。

 密钥的长度为`56`位(密钥通常表示为`64`位的数，但每个第8位都用作奇偶检验，可以忽 略)。密钥可以是任意的`56`位数，且可以在任意的时候改变。

**DES**算法的入口参数有3个：`Key，Data，Mode`。其中`Key`为8个字节共64位，是**DES**算法 的工作密钥；`Data`也为8个字节64位，是要被加密或解密的数据：Mode为**DES**的工作方式，有 两种：加密或解密。

 DES算法的工作过程：若Mode为加密，则用Key对数据Data进行加密，生成Data的密码 形式（64位）作为DES的输出结果；若Mode为解密，则用Key对密码形式的数据Data解密，还 原为Data的明码形式（64位）作为DES的输出结果。
　　 简单地说，算法只不过是加密的一种基本技术，DES基本组建分组是这些技术的一种组合 ，他基于密钥作用于明文，这是众所周知的轮（round）。DES有16轮，这意味着要在明文分 组上16次实施相同的组合技术。

- mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。
- padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。

**参考资料：**

- RFC 4772：https://datatracker.ietf.org/doc/rfc4772/
- DES 维基百科：https://en.wikipedia.org/wiki/Data_Encryption_Standard

#### 1. JavaScript 实现

`DES`算法的入口参数有3个

+ `key、DATA、Mode、padding`
  + `key`为`7个字节`共56位，是DES算法的工作密钥
  + `Data`为`8个字节`64位，是要被加密或被解密的数据
  + `Mode`为`DES`的工作方式
  + `padding`为填充模式，如果加密后密文长度如果达不到指定整数倍（8个字节，16个字节），填充

```JavaScript
// 引用 crypto-js 加密模块 
var CryptoJS = require('crypto-js')

function desEncrypt() {
    var key = CryptoJS.enc.Utf8.parse(desKey),
        iv = CryptoJS.enc.Utf8.parse(desIv),
        srcs = CryptoJS.enc.Utf8.parse(text),
        // CBC 加密模式，Pkcs7 填充方式
        encrypted = CryptoJS.DES.encrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return encrypted.toString();
}

function desDecrypt() {
    var key = CryptoJS.enc.Utf8.parse(desKey),
        iv = CryptoJS.enc.Utf8.parse(desIv),
        srcs = encryptedData,
        // CBC 加密模式，Pkcs7 填充方式
        decrypted = CryptoJS.DES.decrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return decrypted.toString(CryptoJS.enc.Utf8);
}

var text = "I love Python!"       // 待加密对象
var desKey = "6f726c64f2c2057"    // 密钥
var desIv = "0123456789ABCDEF"    // 初始向量

var encryptedData = desEncrypt()
var decryptedData = desDecrypt()

console.log("加密字符串: ", encryptedData)
    console.log("解密字符串: ", decryptedData)

// 加密字符串:  +ndbEkWNw2QAfIYQtwC14w==
// 解密字符串:  I love Python!
```



#### 2. Python 实现

```python
pip install pyDes
```



```python
import binascii
# 加密模式 CBC，填充方式 PAD_PKCS5
from pyDes import des, CBC, PAD_PKCS5

def des_encrypt(key, text, iv):
    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)
    en = k.encrypt(text, padmode=PAD_PKCS5)
    return binascii.b2a_hex(en)

def des_decrypt(key, text, iv):
    k = des(key, CBC, iv, pad=None, padmode=PAD_PKCS5)
    de = k.decrypt(binascii.a2b_hex(text), padmode=PAD_PKCS5)
    return de

if __name__ == '__main__':
    secret_key = '12345678'   # 密钥
    text = 'hello world'   # 加密对象
    iv = secret_key           # 偏移量
    secret_str = des_encrypt(secret_key, text, iv)
    print('加密字符串：', secret_str)
    clear_str = des_decrypt(secret_key, secret_str, iv)
    print('解密字符串：', clear_str)


# 加密字符串：b'302d3abf2421169239f829b38a9545f1'
# 解密字符串：b'I love Python!'
```

- 由于库和版本的不同,同样的加密算法在不一样的语言里结果可能不一致,做逆向时最好是选用node来加密网站数据,不使用python来进行加密





#### 3. 实操练习1

##### 1. 逆向目标

首页：https://www.endata.com.cn/BoxOffice/BO/Month/oneMonth.html

数据：https://www.endata.com.cn/API/GetData.ashx

逆向：加密数据

##### 2. 逆向分析

###### 1. 加密数据定位

- xhr断点数据地址
  - 当前获取的数据是加密的信息,那么在发送ajax的时候一定会在处理响应数据的时候对加密数据进行处理,我们可以直接定位到发送ajax请求的位置,看处理数据的函数   

- 关键字定位
  - 获取的是加密的数据信息,在js是一定要进行解密的处理我们可以直接搜索关键字`decrypt`(关键字搜索的范围比较广,可以多打断点,在重新触发任务看是否能断在)

- 网址定位
  - 根据部分网址有时也能定位成功

###### 2. 加密代码分析

- 根据我们xhr的分析可以定位到他是对数据用`webInstace.shell`进行了解密,我们可以直接跟进函数,看函数做了什么事情
  ![image-20241224110926072](.\image\image-20241224110926072.png)

- 补js代码(缺什么补什么,要是像这种就是一个单独一个文件的可以全扣)
  ![image-20241224111104046](.\image\image-20241224111104046.png)

###### 3.逆向结果

- JavaScript代码

```JavaScript
navigator={
    'userAgent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'

}
// 把整页代码扣进来就行了

// 解密
webInstace.shell("密文")
```

- python代码

```python
import subprocess
from functools import partial
subprocess.Popen = partial(subprocess.Popen, encoding="utf-8")

import requests
import execjs

headers = {
    "Accept": "text/plain, */*; q=0.01",
    "Accept-Language": "zh-CN,zh;q=0.9",
    "Cache-Control": "no-cache",
    "Connection": "keep-alive",
    "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
    "Origin": "https://www.endata.com.cn",
    "Pragma": "no-cache",
    "Sec-Fetch-Dest": "empty",
    "Sec-Fetch-Mode": "cors",
    "Sec-Fetch-Site": "same-origin",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
    "X-Requested-With": "XMLHttpRequest",
    "sec-ch-ua": "^\\^Chromium^^;v=^\\^118^^, ^\\^Google",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "^\\^Windows^^"
}
url = "https://www.endata.com.cn/API/GetData.ashx"
data = {
    "sdate1": "2023-10-13",
    "edate1": "2023-10-15",
    "sdate2": "2023-10-06",
    "edate2": "2023-10-08",
    "MethodName": "BoxOffice_GetWeekendInfoData"
}
response = requests.post(url, headers=headers, data=data)
with open('1111.js', 'r')as f:
    js_code = f.read()

js = execjs.compile(js_code)
result = js.call('webInstace.shell', response.text)
print(result)
```





### 三. AES算法

**环境安装**

```python
pip install pycryptodome -i pip源
```

#### 1. 算法简介

		简介：全称高级加密标准（英文名称：Advanced Encryption Standard），在密码学中又称 Rijndael 加密法，由美国国家标准与技术研究院 （NIST）于 2001 年发布，并在 2002 年成为有效的标准，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用，它本身只有一个密钥，即用来实现加密，也用于解密。

- mode 支持：CBC，CFB，CTR，CTRGladman，ECB，OFB 等。
- padding 支持：ZeroPadding，NoPadding，AnsiX923，Iso10126，Iso97971，Pkcs7 等。

**参考资料：**

- RFC 3268：https://datatracker.ietf.org/doc/rfc3268/
- AES 维基百科：https://en.wikipedia.org/wiki/Advanced_Encryption_Standard



**参数定义：**

1. key length（密钥位数，密码长度）`AES128，AES192，AES256（128 位、192 位或 256 位）`
2. key （密钥，密码）key指的就是密码了，`AES128`就是`128位`的，如果位数不够，某些库可能会自动填充到`128`。
3. IV （向量）IV称为初始向量，不同的IV加密后的字符串是不同的，加密和解密需要相同的IV。
4. mode （加密模式）AES分为几种模式，比如ECB，CBC，CFB等等，这些模式除了ECB由于没有使用IV而不太安全，其他模式差别并没有太明显。
5. padding （填充方式）对于加密解密两端需要使用同一的PADDING模式，大部分PADDING模式为`PKCS5, PKCS7, NOPADDING`。

**加密原理：**

		AES加密算法采用分组密码体制，每个分组数据的长度为`128位16个字节`，密钥长度可以是`128位16个字节`、`192位或256位`，一共有四种加密模式，我们通常采用需要初始向量IV的CBC模式，初始向量的长度也是`128位16个字节`。

#### 2.  JavaScript 实现

类似网站：https://www.dns.com/login.html

```javascript
// 引用 crypto-js 加密模块
var CryptoJS = require('crypto-js')

function tripleAesEncrypt() {
    var key = CryptoJS.enc.Utf8.parse(aesKey),
        iv = CryptoJS.enc.Utf8.parse(aesIv),
        srcs = CryptoJS.enc.Utf8.parse(text),
        // CBC 加密方式，Pkcs7 填充方式
        encrypted = CryptoJS.AES.encrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return encrypted.toString();
}

function tripleAesDecrypt() {
    var key = CryptoJS.enc.Utf8.parse(aesKey),
        iv = CryptoJS.enc.Utf8.parse(aesIv),
        srcs = encryptedData,
        // CBC 加密方式，Pkcs7 填充方式
        decrypted = CryptoJS.AES.decrypt(srcs, key, {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
    return decrypted.toString(CryptoJS.enc.Utf8);
}

var text = "I love Python!"       // 待加密对象
var aesKey = "6f726c64f2c2057c"   // 密钥，16 倍数
var aesIv = "0123456789ABCDEF"    // 偏移量，16 倍数

var encryptedData = tripleAesEncrypt()
var decryptedData = tripleAesDecrypt()

console.log("加密字符串: ", encryptedData)
console.log("解密字符串: ", decryptedData)

// 加密字符串:  dZL7TLJR786VGvuUvqYGoQ==
// 解密字符串:  I love Python!
```



#### 3. 实际案例1

##### 1. 逆向目标

- 目标：建筑市场数据采集

- 主页：https://jzsc.mohurd.gov.cn/data/company

- 接口：https://jzsc.mohurd.gov.cn/api/webApi/dataservice/query/comp/list

- 逆向参数：`data加密`

##### 2. 逆向分析



###### 1.加密数据定位

- 关键字`decrpyt`定位

- xhr断点(同样的可以找到发送ajax的回调位置,不好找的话可以直接在执行一下步,因为他一定会进入到回调的位置进行解密)

![image-20241224134906076](.\image\image-20241224134906076.png)

###### 2. 加密代码分析

- 通过m函数进行解密操作

- 解密方法为AES

###### 3. 逆向结果

- JavaScript代码

```javascript
//下面是使用js的加密参数加上JavaScript的公开加解密包进行解密返参数
//也可以直接扣代码
var cryptojs = require('crypto-js')

function m(t) {
    f = cryptojs.enc.Utf8.parse("jo8j9wGw%6HbxfFn");
    h = cryptojs.enc.Utf8.parse("0123456789ABCDEF");
    var e = cryptojs.enc.Hex.parse(t)
        , n = cryptojs.enc.Base64.stringify(e)
        , a = cryptojs.AES.decrypt(n, f, {
        iv: h,
        mode: cryptojs.mode.CBC,
        padding: cryptojs.pad.Pkcs7
    })
        , r = a.toString(cryptojs.enc.Utf8);
    return r.toString()
}
```

- python代码

```python
import requests
import execjs

headers = {
    "Referer": "https://jzsc.mohurd.gov.cn/data/company",
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
    "timeout": "30000"
}

url = "https://jzsc.mohurd.gov.cn/APi/webApi/dataservice/query/comp/list"
params = {
    "pg": "1",
    "pgsz": "15",
    "total": "450"
}
response = requests.get(url, headers=headers, params=params)

with open('建筑市场.js', 'r', encoding='utf-8')as f:
    js_code = f.read()

js = execjs.compile(js_code)
result = js.call('m', response.text)
print(result)

```



### 四.魔改算法

`魔改算法`通常指的是对现有算法进行修改或改进，以满足特定需求、优化性能或解决特定问题的过程

##### 1. 逆向目标

地址：https://www.aigei.com/sound/class/role?page=7#resContainer

接口:https://www.aigei.com/gei-common/jsonComp/f/awd/log.json?t=5657288%2C30409027%2C29958178%2C5633685%2C5657573%2C5635533%2C30392468%2C5657696%2C5656237%2C5656067%2C30377190%2C5634248%2C41239479%2C2286941%2C29951406%2C69050439%2C5636242%2C2286905%2C5632707%2C68820738&w=rowPc&f=false

需求：解密数据(不做数据要求只需解密)

##### 2. 逆向分析

###### 1.加密数据定位

- xhr断点定位(需要对响应数据解密,找到ajax的回调方法)

![](./images/025.png)

- 关键字`decrypt(`定位(需要碰运气的成分)

![](./images/026.png)

###### 2.加密代码分析

- 跟ajax断点定位到匿名函数
- 分析函数可以得出先将响应的b数据进行分割,这个判断条件是没有成立的可以不用管,直接扣for循环的代码
- 循环中c的赋值对我们用处也不大,我们可以不用扣下来
- 主要代码就是u = (new llii1i1iill).ilil111lii(u)  这个方法会将我们分割之后的数据在进行转换  
- u = ili11liii(u, "il1looOo")会将转换之后的密文进行解密  这两个方法都是要扣的

![](./images/027.png)

- ili11liii方法里可以看到是网站自己封装的一个魔改算法,所以我们需要把GeiJS算法给扣下来,这样的算法最好是我们可以拷贝他整个代码进行格式化,会更加方便些

![](./images/028.png)



###### 3.逆向结果

- JavaScript代码

```JavaScript
var GeiJS = GeiJS || function (a, b) {
    var c = {}
        , e = c.lib = {}
        , g = function () {
    }
        , k = e.Base = {
        extend: function (f) {
            g.prototype = this;
            var l = new g;
            f && l.mixIn(f);
            l.hasOwnProperty("init") || (l.init = function () {
                    l.$super.init.apply(this, arguments)
                }
            );
            l.init.prototype = l;
            l.$super = this;
            return l
        },
        create: function () {
            var f = this.extend();
            f.init.apply(f, arguments);
            return f
        },
        init: function () {
        },
        mixIn: function (f) {
            for (var l in f)
                f.hasOwnProperty(l) && (this[l] = f[l]);
            f.hasOwnProperty("toString") && (this.toString = f.toString)
        },
        clone: function () {
            return this.init.prototype.extend(this)
        }
    }
        , q = e.WordArray = k.extend({
        init: function (f, l) {
            f = this.words = f || [];
            this.sigBytes = l != b ? l : 4 * f.length
        },
        toString: function (f) {
            return (f || t).stringify(this)
        },
        concat: function (f) {
            var l = this.words
                , d = f.words
                , n = this.sigBytes;
            f = f.sigBytes;
            this.clamp();
            if (n % 4)
                for (var w = 0; w < f; w++)
                    l[n + w >>> 2] |= (d[w >>> 2] >>> 24 - w % 4 * 8 & 255) << 24 - (n + w) % 4 * 8;
            else if (65535 < d.length)
                for (w = 0; w < f; w += 4)
                    l[n + w >>> 2] = d[w >>> 2];
            else
                l.push.apply(l, d);
            this.sigBytes += f;
            return this
        },
        clamp: function () {
            var f = this.words
                , l = this.sigBytes;
            f[l >>> 2] &= 4294967295 << 32 - l % 4 * 8;
            f.length = a.ceil(l / 4)
        },
        clone: function () {
            var f = k.clone.call(this);
            f.words = this.words.slice(0);
            return f
        },
        random: function (f) {
            for (var l = [], d = 0; d < f; d += 4)
                l.push(4294967296 * a.random() | 0);
            return new q.init(l, f)
        }
    })
        , v = c.enc = {}
        , t = v.Hex = {
        stringify: function (f) {
            var l = f.words;
            f = f.sigBytes;
            for (var d = [], n = 0; n < f; n++) {
                var w = l[n >>> 2] >>> 24 - n % 4 * 8 & 255;
                d.push((w >>> 4).toString(16));
                d.push((w & 15).toString(16))
            }
            return d.join("")
        },
        parse: function (f) {
            for (var l = f.length, d = [], n = 0; n < l; n += 2)
                d[n >>> 3] |= parseInt(f.substr(n, 2), 16) << 24 - n % 8 * 4;
            return new q.init(d, l / 2)
        }
    }
        , r = v.Latin1 = {
        stringify: function (f) {
            var l = f.words;
            f = f.sigBytes;
            for (var d = [], n = 0; n < f; n++)
                d.push(String.fromCharCode(l[n >>> 2] >>> 24 - n % 4 * 8 & 255));
            return d.join("")
        },
        parse: function (f) {
            for (var l = f.length, d = [], n = 0; n < l; n++)
                d[n >>> 2] |= (f.charCodeAt(n) & 255) << 24 - n % 4 * 8;
            return new q.init(d, l)
        }
    }
        , m = v.Utf8 = {
        stringify: function (f) {
            try {
                return decodeURIComponent(escape(r.stringify(f)))
            } catch (l) {
                throw Error("Malformed UTF-8 data");
            }
        },
        parse: function (f) {
            return r.parse(unescape(encodeURIComponent(f)))
        }
    }
        , u = e.BufferedBlockAlgorithm = k.extend({
        reset: function () {
            this._data = new q.init;
            this._nDataBytes = 0
        },
        _append: function (f) {
            "string" == typeof f && (f = m.parse(f));
            this._data.concat(f);
            this._nDataBytes += f.sigBytes
        },
        _process: function (f) {
            var l = this._data
                , d = l.words
                , n = l.sigBytes
                , w = this.blockSize
                , y = n / (4 * w);
            y = f ? a.ceil(y) : a.max((y | 0) - this._minBufferSize, 0);
            f = y * w;
            n = a.min(4 * f, n);
            if (f) {
                for (var z = 0; z < f; z += w)
                    this._doProcessBlock(d, z);
                z = d.splice(0, f);
                l.sigBytes -= n
            }
            return new q.init(z, n)
        },
        clone: function () {
            var f = k.clone.call(this);
            f._data = this._data.clone();
            return f
        },
        _minBufferSize: 0
    });
    e.Hasher = u.extend({
        cfg: k.extend(),
        init: function (f) {
            this.cfg = this.cfg.extend(f);
            this.reset()
        },
        reset: function () {
            u.reset.call(this);
            this._doReset()
        },
        update: function (f) {
            this._append(f);
            this._process();
            return this
        },
        finalize: function (f) {
            f && this._append(f);
            return this._doFinalize()
        },
        blockSize: 16,
        _createHelper: function (f) {
            return function (l, d) {
                return (new f.init(d)).finalize(l)
            }
        },
        _createHmacHelper: function (f) {
            return function (l, d) {
                return (new h.HMAC.init(f, d)).finalize(l)
            }
        }
    });
    var h = c.algo = {};
    return c
}(Math);

function ili11liii(a, b) {
    b = GeiJS.enc.Utf8.parse(b);
    return GeiJS.OBJFJKET.decrypt({
        ciphertext: GeiJS.enc.Base64.parse(a)
    }, b, {
        mode: GeiJS.mode.FENCTIOP,
        padding: GeiJS.pad.GFACDE
    }).toString(GeiJS.enc.Utf8)
}

ilil111lii = function (a) {
    _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var b = ""
        , c = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/=]/g, ""); c < a.length;) {
        var e = _keyStr.indexOf(a.charAt(c++));
        var g = _keyStr.indexOf(a.charAt(c++));
        var k = _keyStr.indexOf(a.charAt(c++));
        var q = _keyStr.indexOf(a.charAt(c++));
        e = e << 2 | g >> 4;
        g = (g & 15) << 4 | k >> 2;
        var v = (k & 3) << 6 | q;
        b += String.fromCharCode(e);
        64 != k && (b += String.fromCharCode(g));
        64 != q && (b += String.fromCharCode(v))
    }
    return b = _utf8_decode(b)
}

function aa(r) {
    var c = '';
    var E = r.b.split("|");
    for (G = 0; G < E.length; G++) {
        u = E[G];
        u = ilil111lii(u),
            u = ili11liii(u, "il1looOo"),
            u = u.split(",")
        c += u;

    }
    return c
}

var r = {
    "p": 200,
    "b": ""}
    aa(r)
```

- python代码

```python
import requests
import execjs

headers = {
    "referer": "https://www.aigei.com/sound/class/role?page=11",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
}
url = "https://www.aigei.com/gei-common/jsonComp/f/awd/log.json"
params = {
    "t": '5757651,5634335,5739749,5634319,31854576,5657618,5655610,5658078,5635730,5636124,5634306,30392499,5635683,30392510,5636099,30392498,31854584,5635575,5634806,5636275',
    "w": "rowPc",
    "f": "false"
}
response = requests.get(url, headers=headers, params=params)
with open('demo.js', 'r', encoding='utf-8')as f:
    js_code = f.read()
js = execjs.compile(js_code)
res = js.call('aa', response.json())
print(res)

```







## 非对称加密



### 一. 非对称简介		

		与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥`（publickey）`和私有密钥`（privatekey）`。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。

- 常见非对称加密算法 `RSA`、`DSA`。
- 非对称加密算法私钥由数据接收方持有，不会在网络上传递，保证了密钥的安全。
- 非对称加密算法通常比对称加密算法计算复杂，性能消耗高。
- 非对称加密算法可用于数字签名。

![image-20241225144243012](.\image\image-20241225144243012.png)

**注意：**

+ 使用时都是使用公钥加密使用私钥解密，公钥可以公开，私钥自己保留。
+ 算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使加密解密速度慢于对称加密



### 二. 非对称特征

常见JavaScript调试算法

- 搜索关键词 `new JSEncrypt()`，`JSEncrypt` 等，一般会使用 `JSEncrypt `库，会有 new 一个实例对象的操作；
- 搜索关键词 `setPublicKey`、`setKey`、`setPrivateKey`、`getPublicKey` 等，一般实现的代码里都含有设置密钥的过程。

`RSA` 的私钥、公钥、明文、密文长度也有一定对应关系，也可以从这方面初步判断：

| 私钥长度 | 公钥长度 | 明文长度 | 密文长度 |
| -------- | -------- | -------- | -------- |
| 428      | 128      | 1~53     | 88       |
| 812      | 216      | 1~117    | 172      |
| 1588     | 392      | 1~245    | 344      |

#### 2.1  JavaScript 实现

```javascript
// npm install node-rsa --save
// 引用 node-rsa 加密模块
var NodeRSA = require('node-rsa');

function rsaEncrypt() {
    pubKey = new NodeRSA(publicKey,'pkcs8-public');
    var encryptedData = pubKey.encrypt(text, 'base64');
    return encryptedData
}

function rsaDecrypt() {
    priKey = new NodeRSA(privatekey,'pkcs8-private');
    var decryptedData = priKey.decrypt(encryptedData, 'utf8');
    return decryptedData
}

var key = new NodeRSA({b: 512});                    //生成512位秘钥
var publicKey = key.exportKey('pkcs8-public');    //导出公钥
var privatekey = key.exportKey('pkcs8-private');  //导出私钥
var text = "I love Python!"

var encryptedData = rsaEncrypt()
var decryptedData = rsaDecrypt()

console.log("公钥:\n", publicKey)
console.log("私钥:\n", privatekey)
console.log("加密字符串: ", encryptedData)
console.log("解密字符串: ", decryptedData)
```

#### 2.2 Python 实现

模块：`rsa`

```python
import rsa
import base64

def rsa_encrypt(pu_key, t):
    # 公钥加密
    rsas = rsa.encrypt(t.encode("utf-8"), pu_key)
    return base64.b64encode(rsas)

def rsa_decrypt(pr_key, t):
    # 私钥解密
    rsas = rsa.decrypt(base64.b64decode(t), pr_key).decode("utf-8")
    return rsas

if __name__ == "__main__":
    public_key, private_key = rsa.newkeys(512)   # 生成公钥、私钥
    print('公钥：', public_key)
    print('私钥：', private_key)
    text = 'I love Python!'  # 加密对象
    encrypted_str = rsa_encrypt(public_key, text)
    print('加密字符串：', encrypted_str)
    decrypted_str = rsa_decrypt(private_key, encrypted_str)
    print('解密字符串：', decrypted_str)
```



### 三. 案例实战1

#### 1. 采集目标

- 目标：中国移动登录
- 主页：https://login.10086.cn/html/login/email_login.html
- 接口：https://login.10086.cn/login.htm



#### 2.表单逆向分析

##### 1. 加密位置定位

- 关键字搜索`JSEncrypt`, `encrypt`, `password`，也可以xhr断点，然后跟栈找出加密位置。

##### 2. 代码分析

- 账号密码都是由encrypt来进行加密的,所以我们只需要扣encrypt核心代码就好
- 进入函数观察代码,可以看出当前代码是一个RSA的加密算法,我们可以直接扣关键代码

![image-20241225154703948](.\image\image-20241225154703948.png)



##### 3. 逆向代码

- JavaScript工具包使用

```javascript

var JSEncrypt = require('jsencrypt')

function encrypt(_0x32033c) {
    var _0x283d00 = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsgDq4OqxuEisnk2F0EJFmw4xKa5IrcqEYHvqxPs2CHEg2kolhfWA2SjNuGAHxyDDE5MLtOvzuXjBx/5YJtc9zj2xR/0moesS+Vi/xtG1tkVaTCba+TV+Y5C61iyr3FGqr+KOD4/XECu0Xky1W9ZmmaFADmZi7+6gO9wjgVpU9aLcBcw/loHOeJrCqjp7pA98hRJRY+MML8MK15mnC4ebooOva+mJlstW6t/1lghR8WNV8cocxgcHHuXBxgns2MlACQbSdJ8c6Z3RQeRZBzyjfey6JCCfbEKouVrWIUuPphBL3OANfgp0B+QG31bapvePTfXU48TYK0M5kE+8LgbbWQIDAQAB';
    var _0x1defd6 = new JSEncrypt();
    _0x1defd6['setPublicKey'](_0x283d00);
    var _0x4bd6d3 = _0x1defd6['encrypt'](_0x32033c);
    return _0x4bd6d3;
}

console.log(encrypt('12345'));
```



### 四.案例实战2

#### 1.采集目标

- 目标：苏宁登录
- 主页：https://passport.suning.com/ids/login
- 接口：https://passport.suning.com/ids/login

#### 2.表单逆向分析

##### 1.加密位置定位

- 搜索关键字**password2**
- 根据启动器定位  
  ![image-20241225170517116](D:\my_spider_mk\image\image-20241225170517116.png)

- 很直观就能看出为非对称加密方式(使用公钥加密)



##### 2.代码分析

- 通过标准算法库可以直接进行还原定位到公钥的位置观察公钥的生成方式

##### 3.逆向代码

- JavaScript标准库实现  

```javascript
var JSEncrypt = require('jsencrypt')
var loginPBK="MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQComqoAyvbCqO1EGsADwfNTWFQIUbm8CLdeb9TgjGLcz95mAo204SqTYdSEUxFsOnPfROOTxhkhfjbRxBV4/xjS06Y+kkUdiMGFtABIxRQHQIh0LrVvEZQs4NrixxcPI+b1bpE0gO/GAFSNWm9ejhZGj7UnqiHphnSJAVQNz2lgowIDAQAB";
var encrypt = new JSEncrypt();
encrypt.setPublicKey(loginPBK);
var pwd2 = encrypt.encrypt('12341');
console.log(pwd2);
```



- 扣代码的方式可以先把全部的代码都拿下来,分析那些代码是我们想要的，跳转进入到new JSEncrypt()中扣出来，补一点基础环境变量就ok啦。



## SM国密系列

**学习目标:**

1. 熟悉 国密系列加密方式
2. 熟悉 国密实现方式
3. 熟悉 国密实战运用

```
本教程仅供学习交流使用，严禁用于商业用途和非法用途，否则由此产生的一切后果均与作者无关，请各学员自觉遵守相关法律法规。
```



### 一.算法简介

​          事实上从 2010 年开始，我国国家密码管理局就已经开始陆续发布了一系列国产加密算法，这其中就包括 `SM1、SM2、SM3 、SM4、SM7、SM9、ZUC`（祖冲之加密算法）等，`SM` 代表商密，即商业密码，是指用于商业的、不涉及国家秘密的密码技术。`SM1` 和 `SM7 `的算法不公开，其余算法都已成为` ISO/IEC` 国际标准。

在这些国产加密算法中，`SM2、SM3、SM4 ` **三种加密算法是比较常见的**，在爬取部分网站时，也可能会遇到这些算法，所以作为爬虫工程师是有必要了解一下这些算法的，如下图所示某网站就使用了 `SM2` 和 `SM4` 加密算法：

![image-20241226180833028](.\image\image-20241226180833028.png)



#### 1.1 算法分类

| 算法名称 | 算法类别                           | 应用领域             | 特点                                                       |
| -------- | ---------------------------------- | -------------------- | ---------------------------------------------------------- |
| SM1      | 对称（分组）加密算法               | 芯片                 | 分组长度、密钥长度均为 128 比特                            |
| SM2      | 非对称（基于椭圆曲线 ECC）加密算法 | 数据加密             | ECC 椭圆曲线密码机制 256 位，相比 RSA 处理速度快，消耗更少 |
| SM3      | 散列（hash）函数算法               | 完整性校验           | 安全性及效率与 SHA-256 相当，压缩函数更复杂                |
| SM4      | 对称（分组）加密算法               | 数据加密和局域网产品 | 分组长度、密钥长度均为 128 比特，计算轮数多                |
| SM7      | 对称（分组）加密算法               | 非接触式 IC 卡       | 分组长度、密钥长度均为 128 比特                            |
| SM9      | 标识加密算法（IBE）                | 端对端离线安全通讯   | 加密强度等同于 3072 位密钥的 RSA 加密算法                  |
| ZUC      | 对称（序列）加密算法               | 移动通信 4G 网络     | 流密码                                                     |

##### 1.1.1 `SM2` 椭圆曲线公钥加密算法

`SM2` 为椭圆曲线（`ECC`）公钥加密算法，非对称加密，`SM2` 算法和 `RSA `算法都是公钥加密算法，`SM2` 算法是一种更先进安全的算法，在我们国家商用密码体系中被用来替换` RSA` 算法，在不少官方网站会见到此类加密算法。我国学者对椭圆曲线密码的研究从 20 世纪 80 年代开始，目前已取得不少成果，`SM2` 椭圆曲线公钥密码算法比 `RSA `算法有以下优势：

|                      | SM2                            | RSA                    |
| -------------------- | ------------------------------ | ---------------------- |
| 安全性               | 256 位 SM2 强度已超过 RSA-2048 | 一般                   |
| 算法结构             | 基本椭圆曲线（ECC）            | 基于特殊的可逆模幂运算 |
| 计算复杂度           | 完全指数级                     | 亚指数级               |
| 存储空间（密钥长度） | 192-256 bit                    | 2048-4096 bit          |
| 秘钥生成速度         | 较 RSA 算法快百倍以上          | 慢                     |
| 解密加密速度         | 较快                           | 一般                   |

##### 1.1.2` SM4 `分组加密算法

`SM4` 为无线局域网标准的分组加密算法，对称加密，用于替代 `DES/AES` 等国际算法，`SM4` 算法与 `AES `算法具有相同的密钥长度和分组长度，均为 128 位，故对消息进行加解密时，若消息长度过长，需要进行分组，要消息长度不足，则要进行填充。加密算法与密钥扩展算法都采用 32 轮非线性迭代结构，解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。

|          | SM4                                  | DES                                            | AES                                                       |
| -------- | ------------------------------------ | ---------------------------------------------- | --------------------------------------------------------- |
| 计算轮数 | 32                                   | 16（3DES 为 16*3）                             | 10/12/14                                                  |
| 密码部件 | S 盒、非线性变换、线性变换、合成变换 | 标准算术和逻辑运算、先替换后置换，不含线性变换 | S 盒、行移位变换、列混合变换、圈密钥加变换（AddRoundKey） |



### 二.算法实现

#### 1. JavaScript实现

在 JavaScript 中已有比较成熟的实现库，这里推荐 `sm-crypto[4]`，目前支持` SM2、SM3 和 SM4`，需要注意的是，SM2 非对称加密的结果由 `C1、C2、C3` 三部分组成，其中 `C1` 是生成随机数的计算出的椭圆曲线点，`C2 `是密文数据，`C3 `是` SM3` 的摘要值，最开始的国密标准的结果是按 `C1C2C3` 顺序的，新标准的是按 `C1C3C2` 顺序存放的，`sm-crypto` 支持设置` cipherMode`，也就是 `C1C2C3` 的排列顺序。

以 `SM2 `算法为例，实现如下（其他算法和详细用法可参考其官方文档）：

##### 1. `SM2` 

```javascript
// npm install sm-crypto --save

const sm2 = require('sm-crypto').sm2
 
// 1 - C1C3C2，0 - C1C2C3，默认为1
const cipherMode = 1
 
// 获取密钥对
let keypair = sm2.generateKeyPairHex()
let publicKey = keypair.publicKey   // 公钥
let privateKey = keypair.privateKey // 私钥
 
let msgString = "this is the data to be encrypted"
let encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode)    // 加密结果
let decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode) // 解密结果
 
console.log("encryptData: ", encryptData)
console.log("decryptData: ", decryptData)
```

##### 2. `sm3`

```JavaScript
const sm3 = require('sm-crypto').sm3;

const data = 'Hello, SM3!';
const hash = sm3(data);

console.log('SM3 Hash:', hash);
```

##### 3. `sm4`

```JavaScript
const sm4 = require('sm-crypto').sm4;

// 设置SM4密钥（128位，16字节）
const key = '0123456789ABCDEF0123456789ABCDEF';
// 设置SM4加解密模式（ecb、cbc、ctr等）
const mode = 'ecb';

// 加密数据
const plaintext = 'Hello, SM4!';
const ciphertext = sm4.encrypt(plaintext, key, { mode });
console.log('Encrypted:', ciphertext);

// 解密数据
const decryptedText = sm4.decrypt(ciphertext, key, { mode });
console.log('Decrypted:', decryptedText);

```





#### 2`python`实现

在 Python 里面并没有比较官方的库来实现国密算法，这里仅列出了其中两个较为完善的第三方库，需要注意的是，`SM1 和 SM7` 算法不公开，目前大多库仅实现了 `SM2、SM3、SM4` 三种密算法。

若要使用 `SM9` 算法，可下载 `gmssl-python` 源码手动安装。

```python
pip install gmssl
```

##### 1. `sm2`

```python
from gmssl import sm2
 
# 16 进制的公钥和私钥
private_key = '00B9AB0B828FF68872F21A837FC303668428DEA11DCD1B24429D0C99E24EED83D5'
public_key = 'B9C9A6E04E9C91F7BA880429273747D7EF5DDEB0BB2FF6317EB00BEF331A83081A6994B8993F3F5D6EADDDB81872266C87C018FB4162F5AF347B483E24620207'
sm2_crypt = sm2.CryptSM2(public_key=public_key, private_key=private_key)
 
# 待加密数据和加密后数据为 bytes 类型
data = b"this is the data to be encrypted"
enc_data = sm2_crypt.encrypt(data)
dec_data = sm2_crypt.decrypt(enc_data)
 
print('enc_data: ', enc_data.hex())
print('dec_data: ', dec_data)
```

##### 2.`sm3`

- bytes类型的对象，它表示一个包含字节数据的序列。当您使用for 循环遍历 message 时，实际上遍历的是 message 中的每个字节。每个字节都是一个整数，对应于ASCII编码中的字符。所以，在打印每个字节时，您看到的是对应字符的ASCII值

```python
from gmssl import sm3, func


def sm3_hash(message):
    # python实现需要把编码数据转换成列表
    hash_hex = sm3.sm3_hash(func.bytes_to_list(message))
    print(hash_hex)


# main
if __name__ == '__main__':
    message = b"123"  # bytes类型
    sm3_hash(message)

```

##### 3. `sm4`

```
from gmssl import sm4, func

# 创建SM4加密对象
sm4_crypt = sm4.CryptSM4()

key = b'0123456789ABCDEF0123456789ABCDEF'

# 设置密钥
sm4_crypt.set_key(key, sm4.SM4_ENCRYPT)

# 要加密的数据
data = b"Hello, SM4!"

# 加密数据
ciphertext = sm4_crypt.crypt_ecb(func.bytes_to_list(data))

# 将加密后的数据转换为字节串
encrypted_data = bytes(func.list_to_bytes(ciphertext))

# 解密数据（如果需要）
sm4_crypt.set_key(key, sm4.SM4_DECRYPT)
decrypted_data = sm4_crypt.crypt_ecb(ciphertext)
decrypted_data = bytes(func.list_to_bytes(decrypted_data))

print("原始数据:", data.decode("utf-8"))
print("加密后的数据:", encrypted_data.hex())
print("解密后的数据:", decrypted_data.decode("utf-8"))

```



### 三. 实战案例

#### 1. 逆向目标

- 目标： 医保服务
- 主页：https://fuwu.nhsa.gov.cn/nationalHallSt/#/search/medical?code=90000&flag=false&gbFlag=true
- 接口：https://fuwu.nhsa.gov.cn/ebus/fuwu/api/nthl/api/CommQuery/queryFixedHospital
- 逆向参数： 正常请求,正常获取数据
- 请求头
  - `X-Tif-Nonce`
  - `X-Tif-Signature`
  - `X-Tif-Timestamp`
  - `X-Tingyun`
- 载荷数据
  - `encData`
  - `signData`
- 响应数据解密
  - `encData`

#### 2.逆向分析

##### 1. 请求头分析

- 定位加密数据位置
- 当前请求头参数比较有特点我们可以直接通过搜索关键字的方式来进行定位

![image-20241226181342624](.\image\image-20241226181342624.png)

- 可以看到`timestamp`是生成的一个时间戳  
- `nonce` 是一个随机函数生成的数据    
- `signature` 是时间戳拼接随机数在拼接时间进行`sha256`加密的位置    
- `sha256`网站使用的模块导包的方式,我们也可以直接用导包获取
- `X-Tingyun` 在其他位置进行生成,同样的可以根据搜索关键字的方式进行定位
- `X-Tingyun` 赋值给了wo, 接着可以直接搜索wo的赋值位置

![image-20241226181414187](.\image\image-20241226181414187.png)

![image-20241226181441996](.\image\image-20241226181441996.png)

- a是调用的zi函数取16个字符串
- `Gu.key`是一个固定的参数

##### 2.请求头逆向代码

```javascript
// 请求头
function i() {
    var e, t, n, i = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", r = "0123456789";
    return e = o(6, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"),
        t = o(1, i),
        n = o(1, r),
    t + n + e;

    function o(e, t) {
        e = e || 32;
        for (var n = "", i = 0; i < e; i++)
            n += t.charAt(Math.ceil(1e3 * Math.random()) % t.length);
        return n
    }
}

Zi = (
    function () {
        function t(t) {
            return 0 > t ? NaN : 30 >= t ? 0 | Math.random() * (1 << t) : 53 >= t ? (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << t - 30)) * (1 << 30) : NaN
        }

        function e(t, e) {
            for (var n = t.toString(16), r = e - n.length, a = "0"; r > 0; r >>>= 1,
                a += a)
                1 & r && (n = a + n);
            return n
        }

        return function (n) {
            return n || (n = ""),
            e(t(32), 8) + n + e(t(16), 4) + n + e(16384 | t(12), 4) + n + e(32768 | t(14), 4) + n + e(t(48), 12)
        }
    }())

function get_heade() {
    var r = xxx("6c27").sha256
        , s = Math.ceil((new Date).getTime() / 1e3)
        , h = i()
        , f = s + h + s;
    var a = Zi().substring(0, 16)
    var aa = "c=B|" + '4Nl_NnGbjwY';
    aa += ";x=" + a
    // console.log(aa)
    var headers = {};
    headers["x-tif-signature"] = r(f);
    headers["x-tif-timestamp"] = s;
    headers["x-tif-nonce"] = h;
    headers["X-Tingyun"] = aa;
    return headers

}

console.log(get_heade());
```

##### 3. 载荷分析

- 载荷数据同样的可以根据关键字来进行定位
- 或者通过xhr的方式定位也行,但是距离会有些远

![image-20241226181518347](.\image\image-20241226181518347.png)

- 可以看到他的参数加密就是在请求头下面进行的
- `signData`是`sm2`加密
- `encData`是`sm4`加密

##### 4,载荷加密核心代码

```javascript
// 请求载荷 signData
function p(e) {
    var t = new Array
        , n = 0;
    for (var i in e)
        t[n] = i,
            n++;
    var r = [].concat(t).sort()
        , o = {};
    for (var a in r)
        o[r[a]] = e[r[a]];
    return o
}

function m(e) {
    var t = {}
        , n = ["signData", "encData", "extra"];
    for (var i in e)
        e.hasOwnProperty(i) && !n.includes(i) && null != e[i] && (t[i] = e[i]);
    return t
}

function v(e) {
    var t = [];
    for (var n in e)
        if (e.hasOwnProperty(n) && (e[n] || "".concat(e[n])))
            if ("data" === n) {
                var i = Object.assign({}, e[n]);
                for (var r in i) {
                    if ("number" != typeof i[r] && "boolean" != typeof i[r] || (i[r] = "" + i[r]),
                    Array.isArray(i[r]) && !i[r].length && delete i[r],
                    Array.isArray(i[r]) && i[r].length > 0)
                        for (var o = 0; o < i[r].length; o++)
                            i[r][o] = p(i[r][o]);
                    null != i[r] && i[r] || delete i[r]
                }
                var a = p(i);
                t.push("".concat(n, "=").concat(JSON.stringify(a)))
            } else
                t.push("".concat(n, "=").concat(e[n]));
    return t.push("key=".concat('NMVFVILMKT13GEMD3BKPKCTBOQBPZR2P')),
        t.join("&")
}

sm4 = require('sm-crypto').sm4;
r = xxx("68b2")
o = r.sm2
a = r.sm3
s = r.sm4
l = (xxx("94f8"),
            {
                appCode: "T98HPCGN5ZVVQBS8LZQNOAEXVI9GYHKQ",
                version: "1.0.0",
                appSecret: "NMVFVILMKT13GEMD3BKPKCTBOQBPZR2P",
                publicKey: "BEKaw3Qtc31LG/hTPHFPlriKuAn/nzTWl8LiRxLw4iQiSUIyuglptFxNkdCiNXcXvkqTH79Rh/A2sEFU6hjeK3k=",
                privateKey: "AJxKNdmspMaPGj+onJNoQ0cgWk2E3CYFWKBJhpcJrAtC",
                publicKeyType: "base64",
                privateKeyType: "base64"
            })
signData = function (t) {
    e = xxx("b639").Buffer
    var n = m(t)
        , i = p(n);

    i.data = p(i.data);
    var r = v(i)
        // console.log(r)

        , a = o.doSignature(r, e.from(l.privateKey, "base64").toString("hex"), {
        hash: !0
    });
    return e.from(a, "hex").toString("base64")

}

// encData
function A(e) {
    var t, n, i = new Array;
    t = e.length;
    for (var r = 0; r < t; r++)
        (n = e.charCodeAt(r)) >= 65536 && n <= 1114111 ? (i.push(n >> 18 & 7 | 240),
            i.push(n >> 12 & 63 | 128),
            i.push(n >> 6 & 63 | 128),
            i.push(63 & n | 128)) : n >= 2048 && n <= 65535 ? (i.push(n >> 12 & 15 | 224),
            i.push(n >> 6 & 63 | 128),
            i.push(63 & n | 128)) : n >= 128 && n <= 2047 ? (i.push(n >> 6 & 31 | 192),
            i.push(63 & n | 128)) : i.push(255 & n);
    return i
}
function b(t, n) {
    var i = 16 - parseInt(n.length % 16);
    n = n.concat(new Array(i).fill(i));
    var r = s.encrypt(n, t);
    return e.from(r).toString("hex")
}
function y(e, t) {
                return A(b(A(e.substr(0, 16)), A(t)).toUpperCase().substr(0, 16))
            }
function encdata(e) {

        var t = e.data && JSON.stringify(e.data)
            , n = A(t);
        u = e.appCode;
        c = l.appSecret;
        var i = y(u, c)
            , r = b(i, n);
        return r.toUpperCase()

}

function get_data(dd) {
    sign_data = signData(dd)
    encData = encdata(dd)
    return {
        "sign_data": sign_data,
        'encData': encData
    }
}
ccc = {
    "data": {
        "addr": "",
        "regnCode": "430100",
        "medinsName": "",
        "medinsLvCode": "",
        "medinsTypeCode": "",
        "openElec": "",
        "pageNum": 7,
        "pageSize": 10,
        "queryDataSource": "es"
    },
    "appCode": "T98HPCGN5ZVVQBS8LZQNOAEXVI9GYHKQ",
    "version": "1.0.0",
    "encType": "SM4",
    "signType": "SM2",
    "timestamp": 1697963445
}
console.log(get_data(ccc))
```

##### 5.数据解密分析

- 解密的代码定位比较好定位，因为他一点会在发`ajax`之后进行回调，我们直接跟`xhr`下一步就行
- 根据关键字可以进行推断请求成功之后的回调,`then()` ,`done()`, `success()` , `onload ` 都是请求成功之后的一些回调关键字

![image-20241226181608063](.\image\image-20241226181608063.png)

- 在接着往下跟就能找到解密的位置

![image-20241226181630856](.\image\image-20241226181630856.png)

- 接着就能正常扣代码



##### 6.数据解密核心代码

```JavaScript
// 数据解密
function dec(t) {
    e = xxx("b639").Buffer
    var n = e.from(t.data.data.encData, "hex")
      , i = function(t, n) {
        var i = s.decrypt(n, t)
          , r = i[i.length - 1];
        return i = i.slice(0, i.length - r),
        e.from(i).toString("utf-8")
    }(y(l.appCode, l.appSecret), n);
    return JSON.parse(i)
}

console.log(dec({
    "code": 0,
    "data": {
        "signData": "HTSkheUV+TJODCl0GLtDeqooXR2uOhL1Oi+PbGl/1d/iCi50VNxF343JshmzXr2M/KJw05ivuckKB1xjUC9PrQ==",
        "encType": "SM4",
        "data": {
            "encData": ""
        },
        "signType": "SM2",
        "appCode": "T98HPCGN5ZVVQBS8LZQNOAEXVI9GYHKQ",
        "version": "1.0.0",
        "timestamp": "1697965870377"
    },
    "message": "成功",
    "timestamp": "1697965870",
    "type": "success"
}))
```

##### 7.python多页数据获取

```python
import requests
import execjs


class YiBao():

    def __init__(self):
        self.headers = {
            "Origin": "https://fuwu.nhsa.gov.cn",
            "Referer": "https://fuwu.nhsa.gov.cn/nationalHallSt/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36",
        }
        self.data = {
            "data": {
                "addr": "",
                "regnCode": "430100",
                "medinsName": "",
                "medinsLvCode": "",
                "medinsTypeCode": "",
                "openElec": "",
                "pageNum": 3,
                "pageSize": 10,
                "queryDataSource": "es"
            },
            "appCode": "T98HPCGN5ZVVQBS8LZQNOAEXVI9GYHKQ",
            "version": "1.0.0",
            "encType": "SM4",
            "signType": "SM2",
            "timestamp": 1697810848
        }
        self.url = "https://fuwu.nhsa.gov.cn/ebus/fuwu/api/nthl/api/CommQuery/queryFixedHospital"
        self.js = execjs.compile(open('demo.js', encoding='utf-8').read())

    def get_data(self, page):

        head = self.js.call('get_heade')
        # print(head)
        self.headers['x-tif-nonce'] = head['x-tif-nonce']
        self.headers['x-tif-timestamp'] = str(head['x-tif-timestamp'])
        self.headers['x-tif-nonce'] = head['x-tif-nonce']
        self.headers['X-Tingyun'] = head['X-Tingyun']
        self.data['timestamp'] = head['x-tif-timestamp']
        self.data['data']['pageNum'] = page
        res = self.js.call('get_data', self.data)

        data = {"data": {"data": {
            "encData": res['encData']},
            "appCode": "T98HPCGN5ZVVQBS8LZQNOAEXVI9GYHKQ", "version": "1.0.0", "encType": "SM4",
            "signType": "SM2", "timestamp": head['x-tif-timestamp'],
            "signData": res['sign_data']}}
        # print(self.headers)
        response = requests.post(self.url, headers=self.headers, json=data)
        return response.json()

    def parse_data(self, res):
        res_data = self.js.call('dec', res)
        for i in res_data['list']:
            item = {}
            item['medinsTypeName'] = i['medinsTypeName']
            item['medinsName'] = i['medinsName']
            item['medinsLvName'] = i['medinsLvName']
            print(item)

    def main(self):
        for i in range(1, 5):
            response = self.get_data(i)
            self.parse_data(response)


if __name__ == '__main__':
    yb = YiBao()
    yb.main()

```
